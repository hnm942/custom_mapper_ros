Cần tập trung vào vấn đề xây dựng map:
 Luồng pointcloud đi vào -> Lọc pointcloud -> Storage ->
 Đưa nó lên map
- Tập trung việc tạo map, tạo bản đồ ==> publish liên tục lúc build map
==> global map quản lý việc khởi tạo và lưu 
hay là obstace map sẽ quản lý việc này




Phân tích rõ từng chức năng
==> Global map: tập trung quản lý dữ liệu push, remove các dữ liệu trong obstacle
grid, cost grid và distance grid
==> obstace map: sẽ lưu vị trí các obstacle
??? cần giải quyết vấn đề association data
==> Dữ liệu lưu trong obstacle sẽ là:
+ Mảng theo grid.
+ Mảng theo octree.

==> Sau khi custom_mapper_ros <front end> đẩy thông tin sang custom mapper
custom mapper sẽ buff nó vào buffer ??? truyền địa chỉ con trỏ hằng 


Tổng kết:
- Khi build map: 
    gọi service 
- Bình thường 
    load map

Map sẽ được biểu thị bằng voxel <sensor_msgs::PointCloud2>

Association: ICP?? Ceres

Các chức năng của voxel grid
- Khởi tạo
  VoxelGrid();
  VoxelGrid(const double origin[3], const double world_dimensions[3], const double resolution);
  VoxelGrid(const double origin[3], const int grid_dimensions[3], const double resolution, const std::vector<T>& data);
- Lấy kích cỡ grid của map
  void GetGridDimensions(int dimensions[3]) const
- Biến đổi tạo độ world về tọa độ grid và ngược lại
  void WorldToGrid(const double xyz[3], int ixyz[3]) const;
  void GridToWorld(const int ixyz[3], double* xyz) const;
  void IndexToGrid(int ind, int ixyz[3]) const;
  void IndexToWorld(int ind, double xyz[3]) const;
- Kiểm tra điểm này có trong map khoong
  bool IsInMap(int index) const;
  bool IsInMap(const int ixyz[3]) const;
  bool IsInMap(const double xyz[3]) const;
- Update Origin:
  std::vector<int> UpdateOrigin(const double xyz[3]);
  std::vector<int> UpdateOrigin(const double x, const double y, const double z);
- Lấy thông tin về Biến
  void WorldToVoxels(const double xyz[3], int voxels[3]) const;
  int GetNumCells() const
  std::vector<T> GetData() const
  double GetResolution() const
  void GetOrigin(double xyz[3]) const;
  void PrintIndexes() const;
  void PrintValues() const;
  void PrintWorldX() const;
  void PrintWorldZ() const;
  void PrintState() const;
  void ComputeShiftVoxels(const int new_lower_left_voxels[3], int voxel_shift[3]) const;
  void Reset(T reset_value);
  T ReadValue(const int ind) const;
  T ReadValue(const int ixyz[3]) const;
  T ReadValue(const double xyz[3]) const;
  T ReadValue(const double x, const double y, const double z) const;
- Ghi giá trị cho biến
  void WriteValue(const int ixyz[3], T value);
  void WriteValue(const double xyz[3], T value);
  void WriteValue(const double x, const double y, const double z, T value);

==> Quản lý map theo octree, octree chỉ là một biến của voxel grid
Các chức năng của occupancy grid 

Nên tổ chức lưu Octree theo tọa độ grid vì dễ dàng cho việc tổ chức dữ liệu 


==> Octree đầu vào sẽ là kiểu int, voxel map cụ thể occupancy grid sẽ có vai trò chuyển từ tọa độ world về tọa độ grid
grid dimension nên là 2^n ==> unit test


